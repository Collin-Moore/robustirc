// Code generated by protoc-gen-gogo.
// source: snapshot.proto
// DO NOT EDIT!

package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import errors "errors"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Bool represents a boolean which can either be unset, true or
// false. This quirk is necessary because proto3 does not distinguish
// the default value (false) from a field not being set, which would
// not allow us to do upgrades from older versions of RobustIRC to
// newer versions of RobustIRC which introduce a new boolean field.
type Bool int32

const (
	Bool_UNSET Bool = 0
	Bool_TRUE  Bool = 1
	Bool_FALSE Bool = 2
)

var Bool_name = map[int32]string{
	0: "UNSET",
	1: "TRUE",
	2: "FALSE",
}
var Bool_value = map[string]int32{
	"UNSET": 0,
	"TRUE":  1,
	"FALSE": 2,
}

func (x Bool) String() string {
	return proto1.EnumName(Bool_name, int32(x))
}
func (Bool) EnumDescriptor() ([]byte, []int) { return fileDescriptorSnapshot, []int{0} }

// Timestamp serializes a Go time.Time value with correct IsZero()
// semantics. Merely serializing the UnixNano() value is not
// sufficient, see https://play.golang.org/p/n3ZWGwZCKR
type Timestamp struct {
	UnixNano int64 `protobuf:"varint,1,opt,name=unix_nano,json=unixNano,proto3" json:"unix_nano,omitempty"`
	IsZero   bool  `protobuf:"varint,2,opt,name=is_zero,json=isZero,proto3" json:"is_zero,omitempty"`
}

func (m *Timestamp) Reset()                    { *m = Timestamp{} }
func (m *Timestamp) String() string            { return proto1.CompactTextString(m) }
func (*Timestamp) ProtoMessage()               {}
func (*Timestamp) Descriptor() ([]byte, []int) { return fileDescriptorSnapshot, []int{0} }

// Snapshot contains the entire state of an IRCServer object, so that
// a new IRCServer object can be created with exactly the same state.
type Snapshot struct {
	Sessions      []*Snapshot_Session          `protobuf:"bytes,1,rep,name=sessions" json:"sessions,omitempty"`
	Channels      []*Snapshot_Channel          `protobuf:"bytes,2,rep,name=channels" json:"channels,omitempty"`
	Svsholds      map[string]*Snapshot_SVSHold `protobuf:"bytes,3,rep,name=svsholds" json:"svsholds,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	LastProcessed *RobustId                    `protobuf:"bytes,4,opt,name=last_processed,json=lastProcessed" json:"last_processed,omitempty"`
	Config        *Snapshot_Config             `protobuf:"bytes,5,opt,name=config" json:"config,omitempty"`
	// last_included_index is the last ircstore message index which was
	// included when taking the snapshot. This is relevant to store this
	// snapshot in fsm.lastSnapshotState when restoring after ircstore
	// was deleted.
	LastIncludedIndex uint64 `protobuf:"varint,6,opt,name=last_included_index,json=lastIncludedIndex,proto3" json:"last_included_index,omitempty"`
}

func (m *Snapshot) Reset()                    { *m = Snapshot{} }
func (m *Snapshot) String() string            { return proto1.CompactTextString(m) }
func (*Snapshot) ProtoMessage()               {}
func (*Snapshot) Descriptor() ([]byte, []int) { return fileDescriptorSnapshot, []int{1} }

func (m *Snapshot) GetSessions() []*Snapshot_Session {
	if m != nil {
		return m.Sessions
	}
	return nil
}

func (m *Snapshot) GetChannels() []*Snapshot_Channel {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *Snapshot) GetSvsholds() map[string]*Snapshot_SVSHold {
	if m != nil {
		return m.Svsholds
	}
	return nil
}

func (m *Snapshot) GetLastProcessed() *RobustId {
	if m != nil {
		return m.LastProcessed
	}
	return nil
}

func (m *Snapshot) GetConfig() *Snapshot_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

type Snapshot_IRCPrefix struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	User string `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	Host string `protobuf:"bytes,3,opt,name=host,proto3" json:"host,omitempty"`
}

func (m *Snapshot_IRCPrefix) Reset()                    { *m = Snapshot_IRCPrefix{} }
func (m *Snapshot_IRCPrefix) String() string            { return proto1.CompactTextString(m) }
func (*Snapshot_IRCPrefix) ProtoMessage()               {}
func (*Snapshot_IRCPrefix) Descriptor() ([]byte, []int) { return fileDescriptorSnapshot, []int{1, 0} }

type Snapshot_Session struct {
	Id                  *RobustId           `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Auth                string              `protobuf:"bytes,2,opt,name=auth,proto3" json:"auth,omitempty"`
	Nick                string              `protobuf:"bytes,3,opt,name=nick,proto3" json:"nick,omitempty"`
	Username            string              `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
	Realname            string              `protobuf:"bytes,5,opt,name=realname,proto3" json:"realname,omitempty"`
	Channels            []string            `protobuf:"bytes,6,rep,name=channels" json:"channels,omitempty"`
	LastActivity        *Timestamp          `protobuf:"bytes,7,opt,name=last_activity,json=lastActivity" json:"last_activity,omitempty"`
	Operator            bool                `protobuf:"varint,8,opt,name=operator,proto3" json:"operator,omitempty"`
	AwayMsg             string              `protobuf:"bytes,9,opt,name=away_msg,json=awayMsg,proto3" json:"away_msg,omitempty"`
	Created             int64               `protobuf:"varint,22,opt,name=created,proto3" json:"created,omitempty"`
	ThrottlingExponent  int64               `protobuf:"varint,10,opt,name=throttling_exponent,json=throttlingExponent,proto3" json:"throttling_exponent,omitempty"`
	InvitedTo           []string            `protobuf:"bytes,11,rep,name=invited_to,json=invitedTo" json:"invited_to,omitempty"`
	Modes               []string            `protobuf:"bytes,12,rep,name=modes" json:"modes,omitempty"`
	Svid                string              `protobuf:"bytes,13,opt,name=svid,proto3" json:"svid,omitempty"`
	Pass                string              `protobuf:"bytes,14,opt,name=pass,proto3" json:"pass,omitempty"`
	Server              bool                `protobuf:"varint,15,opt,name=server,proto3" json:"server,omitempty"`
	LastClientMessageId uint64              `protobuf:"varint,17,opt,name=last_client_message_id,json=lastClientMessageId,proto3" json:"last_client_message_id,omitempty"`
	IrcPrefix           *Snapshot_IRCPrefix `protobuf:"bytes,18,opt,name=irc_prefix,json=ircPrefix" json:"irc_prefix,omitempty"`
	LastNonPing         *Timestamp          `protobuf:"bytes,19,opt,name=last_non_ping,json=lastNonPing" json:"last_non_ping,omitempty"`
	LastSolvedCaptcha   *Timestamp          `protobuf:"bytes,20,opt,name=last_solved_captcha,json=lastSolvedCaptcha" json:"last_solved_captcha,omitempty"`
	LoggedIn            Bool                `protobuf:"varint,21,opt,name=logged_in,json=loggedIn,proto3,enum=proto.Bool" json:"logged_in,omitempty"`
	RemoteAddr          string              `protobuf:"bytes,23,opt,name=remote_addr,json=remoteAddr,proto3" json:"remote_addr,omitempty"`
}

func (m *Snapshot_Session) Reset()                    { *m = Snapshot_Session{} }
func (m *Snapshot_Session) String() string            { return proto1.CompactTextString(m) }
func (*Snapshot_Session) ProtoMessage()               {}
func (*Snapshot_Session) Descriptor() ([]byte, []int) { return fileDescriptorSnapshot, []int{1, 1} }

func (m *Snapshot_Session) GetId() *RobustId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Snapshot_Session) GetLastActivity() *Timestamp {
	if m != nil {
		return m.LastActivity
	}
	return nil
}

func (m *Snapshot_Session) GetIrcPrefix() *Snapshot_IRCPrefix {
	if m != nil {
		return m.IrcPrefix
	}
	return nil
}

func (m *Snapshot_Session) GetLastNonPing() *Timestamp {
	if m != nil {
		return m.LastNonPing
	}
	return nil
}

func (m *Snapshot_Session) GetLastSolvedCaptcha() *Timestamp {
	if m != nil {
		return m.LastSolvedCaptcha
	}
	return nil
}

type Snapshot_Channel struct {
	Name      string                             `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	TopicNick string                             `protobuf:"bytes,2,opt,name=topic_nick,json=topicNick,proto3" json:"topic_nick,omitempty"`
	TopicTime *Timestamp                         `protobuf:"bytes,3,opt,name=topic_time,json=topicTime" json:"topic_time,omitempty"`
	Topic     string                             `protobuf:"bytes,4,opt,name=topic,proto3" json:"topic,omitempty"`
	Nicks     map[string]*Snapshot_Channel_Modes `protobuf:"bytes,5,rep,name=nicks" json:"nicks,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Modes     []string                           `protobuf:"bytes,6,rep,name=modes" json:"modes,omitempty"`
	Bans      []*Snapshot_Channel_BanPattern     `protobuf:"bytes,7,rep,name=bans" json:"bans,omitempty"`
}

func (m *Snapshot_Channel) Reset()                    { *m = Snapshot_Channel{} }
func (m *Snapshot_Channel) String() string            { return proto1.CompactTextString(m) }
func (*Snapshot_Channel) ProtoMessage()               {}
func (*Snapshot_Channel) Descriptor() ([]byte, []int) { return fileDescriptorSnapshot, []int{1, 2} }

func (m *Snapshot_Channel) GetTopicTime() *Timestamp {
	if m != nil {
		return m.TopicTime
	}
	return nil
}

func (m *Snapshot_Channel) GetNicks() map[string]*Snapshot_Channel_Modes {
	if m != nil {
		return m.Nicks
	}
	return nil
}

func (m *Snapshot_Channel) GetBans() []*Snapshot_Channel_BanPattern {
	if m != nil {
		return m.Bans
	}
	return nil
}

// Modes is a workaround because proto3 does not support
// map<string, repeated string>.
type Snapshot_Channel_Modes struct {
	Mode []string `protobuf:"bytes,1,rep,name=mode" json:"mode,omitempty"`
}

func (m *Snapshot_Channel_Modes) Reset()         { *m = Snapshot_Channel_Modes{} }
func (m *Snapshot_Channel_Modes) String() string { return proto1.CompactTextString(m) }
func (*Snapshot_Channel_Modes) ProtoMessage()    {}
func (*Snapshot_Channel_Modes) Descriptor() ([]byte, []int) {
	return fileDescriptorSnapshot, []int{1, 2, 0}
}

type Snapshot_Channel_BanPattern struct {
	Pattern string `protobuf:"bytes,1,opt,name=pattern,proto3" json:"pattern,omitempty"`
	Regexp  string `protobuf:"bytes,2,opt,name=regexp,proto3" json:"regexp,omitempty"`
}

func (m *Snapshot_Channel_BanPattern) Reset()         { *m = Snapshot_Channel_BanPattern{} }
func (m *Snapshot_Channel_BanPattern) String() string { return proto1.CompactTextString(m) }
func (*Snapshot_Channel_BanPattern) ProtoMessage()    {}
func (*Snapshot_Channel_BanPattern) Descriptor() ([]byte, []int) {
	return fileDescriptorSnapshot, []int{1, 2, 2}
}

type Snapshot_SVSHold struct {
	Added    *Timestamp `protobuf:"bytes,1,opt,name=added" json:"added,omitempty"`
	Duration string     `protobuf:"bytes,2,opt,name=duration,proto3" json:"duration,omitempty"`
	Reason   string     `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *Snapshot_SVSHold) Reset()                    { *m = Snapshot_SVSHold{} }
func (m *Snapshot_SVSHold) String() string            { return proto1.CompactTextString(m) }
func (*Snapshot_SVSHold) ProtoMessage()               {}
func (*Snapshot_SVSHold) Descriptor() ([]byte, []int) { return fileDescriptorSnapshot, []int{1, 3} }

func (m *Snapshot_SVSHold) GetAdded() *Timestamp {
	if m != nil {
		return m.Added
	}
	return nil
}

type Snapshot_Config struct {
	Revision                uint64               `protobuf:"varint,1,opt,name=revision,proto3" json:"revision,omitempty"`
	Irc                     *Snapshot_Config_IRC `protobuf:"bytes,2,opt,name=irc" json:"irc,omitempty"`
	SessionExpiration       string               `protobuf:"bytes,3,opt,name=session_expiration,json=sessionExpiration,proto3" json:"session_expiration,omitempty"`
	PostMessageCooloff      string               `protobuf:"bytes,4,opt,name=post_message_cooloff,json=postMessageCooloff,proto3" json:"post_message_cooloff,omitempty"`
	TrustedBridges          map[string]string    `protobuf:"bytes,5,rep,name=trusted_bridges,json=trustedBridges" json:"trusted_bridges,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	CaptchaUrl              string               `protobuf:"bytes,6,opt,name=captcha_url,json=captchaUrl,proto3" json:"captcha_url,omitempty"`
	CaptchaHmacSecret       string               `protobuf:"bytes,7,opt,name=captcha_hmac_secret,json=captchaHmacSecret,proto3" json:"captcha_hmac_secret,omitempty"`
	CaptchaRequiredForLogin bool                 `protobuf:"varint,8,opt,name=captcha_required_for_login,json=captchaRequiredForLogin,proto3" json:"captcha_required_for_login,omitempty"`
	MaxSessions             uint64               `protobuf:"varint,9,opt,name=max_sessions,json=maxSessions,proto3" json:"max_sessions,omitempty"`
	MaxChannels             uint64               `protobuf:"varint,10,opt,name=max_channels,json=maxChannels,proto3" json:"max_channels,omitempty"`
	Banned                  map[string]string    `protobuf:"bytes,11,rep,name=banned" json:"banned,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Snapshot_Config) Reset()                    { *m = Snapshot_Config{} }
func (m *Snapshot_Config) String() string            { return proto1.CompactTextString(m) }
func (*Snapshot_Config) ProtoMessage()               {}
func (*Snapshot_Config) Descriptor() ([]byte, []int) { return fileDescriptorSnapshot, []int{1, 5} }

func (m *Snapshot_Config) GetIrc() *Snapshot_Config_IRC {
	if m != nil {
		return m.Irc
	}
	return nil
}

func (m *Snapshot_Config) GetTrustedBridges() map[string]string {
	if m != nil {
		return m.TrustedBridges
	}
	return nil
}

func (m *Snapshot_Config) GetBanned() map[string]string {
	if m != nil {
		return m.Banned
	}
	return nil
}

type Snapshot_Config_IRC struct {
	Operators []*Snapshot_Config_IRC_Operator `protobuf:"bytes,1,rep,name=operators" json:"operators,omitempty"`
	Services  []*Snapshot_Config_IRC_Service  `protobuf:"bytes,2,rep,name=services" json:"services,omitempty"`
}

func (m *Snapshot_Config_IRC) Reset()         { *m = Snapshot_Config_IRC{} }
func (m *Snapshot_Config_IRC) String() string { return proto1.CompactTextString(m) }
func (*Snapshot_Config_IRC) ProtoMessage()    {}
func (*Snapshot_Config_IRC) Descriptor() ([]byte, []int) {
	return fileDescriptorSnapshot, []int{1, 5, 0}
}

func (m *Snapshot_Config_IRC) GetOperators() []*Snapshot_Config_IRC_Operator {
	if m != nil {
		return m.Operators
	}
	return nil
}

func (m *Snapshot_Config_IRC) GetServices() []*Snapshot_Config_IRC_Service {
	if m != nil {
		return m.Services
	}
	return nil
}

type Snapshot_Config_IRC_Operator struct {
	Name     string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *Snapshot_Config_IRC_Operator) Reset()         { *m = Snapshot_Config_IRC_Operator{} }
func (m *Snapshot_Config_IRC_Operator) String() string { return proto1.CompactTextString(m) }
func (*Snapshot_Config_IRC_Operator) ProtoMessage()    {}
func (*Snapshot_Config_IRC_Operator) Descriptor() ([]byte, []int) {
	return fileDescriptorSnapshot, []int{1, 5, 0, 0}
}

type Snapshot_Config_IRC_Service struct {
	Password string `protobuf:"bytes,1,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *Snapshot_Config_IRC_Service) Reset()         { *m = Snapshot_Config_IRC_Service{} }
func (m *Snapshot_Config_IRC_Service) String() string { return proto1.CompactTextString(m) }
func (*Snapshot_Config_IRC_Service) ProtoMessage()    {}
func (*Snapshot_Config_IRC_Service) Descriptor() ([]byte, []int) {
	return fileDescriptorSnapshot, []int{1, 5, 0, 1}
}

func init() {
	proto1.RegisterType((*Timestamp)(nil), "proto.Timestamp")
	proto1.RegisterType((*Snapshot)(nil), "proto.Snapshot")
	proto1.RegisterType((*Snapshot_IRCPrefix)(nil), "proto.Snapshot.IRCPrefix")
	proto1.RegisterType((*Snapshot_Session)(nil), "proto.Snapshot.Session")
	proto1.RegisterType((*Snapshot_Channel)(nil), "proto.Snapshot.Channel")
	proto1.RegisterType((*Snapshot_Channel_Modes)(nil), "proto.Snapshot.Channel.Modes")
	proto1.RegisterType((*Snapshot_Channel_BanPattern)(nil), "proto.Snapshot.Channel.BanPattern")
	proto1.RegisterType((*Snapshot_SVSHold)(nil), "proto.Snapshot.SVSHold")
	proto1.RegisterType((*Snapshot_Config)(nil), "proto.Snapshot.Config")
	proto1.RegisterType((*Snapshot_Config_IRC)(nil), "proto.Snapshot.Config.IRC")
	proto1.RegisterType((*Snapshot_Config_IRC_Operator)(nil), "proto.Snapshot.Config.IRC.Operator")
	proto1.RegisterType((*Snapshot_Config_IRC_Service)(nil), "proto.Snapshot.Config.IRC.Service")
	proto1.RegisterEnum("proto.Bool", Bool_name, Bool_value)
}
func (m *Timestamp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Timestamp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UnixNano != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.UnixNano))
	}
	if m.IsZero {
		data[i] = 0x10
		i++
		if m.IsZero {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Snapshot) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Snapshot) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, msg := range m.Sessions {
			data[i] = 0xa
			i++
			i = encodeVarintSnapshot(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Channels) > 0 {
		for _, msg := range m.Channels {
			data[i] = 0x12
			i++
			i = encodeVarintSnapshot(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Svsholds) > 0 {
		for k, _ := range m.Svsholds {
			data[i] = 0x1a
			i++
			v := m.Svsholds[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovSnapshot(uint64(len(k))) + 1 + msgSize + sovSnapshot(uint64(msgSize))
			i = encodeVarintSnapshot(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintSnapshot(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintSnapshot(data, i, uint64(v.Size()))
			n1, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n1
		}
	}
	if m.LastProcessed != nil {
		data[i] = 0x22
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.LastProcessed.Size()))
		n2, err := m.LastProcessed.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Config != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.Config.Size()))
		n3, err := m.Config.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.LastIncludedIndex != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.LastIncludedIndex))
	}
	return i, nil
}

func (m *Snapshot_IRCPrefix) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Snapshot_IRCPrefix) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.User) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.User)))
		i += copy(data[i:], m.User)
	}
	if len(m.Host) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.Host)))
		i += copy(data[i:], m.Host)
	}
	return i, nil
}

func (m *Snapshot_Session) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Snapshot_Session) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.Id.Size()))
		n4, err := m.Id.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Auth) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.Auth)))
		i += copy(data[i:], m.Auth)
	}
	if len(m.Nick) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.Nick)))
		i += copy(data[i:], m.Nick)
	}
	if len(m.Username) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.Username)))
		i += copy(data[i:], m.Username)
	}
	if len(m.Realname) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.Realname)))
		i += copy(data[i:], m.Realname)
	}
	if len(m.Channels) > 0 {
		for _, s := range m.Channels {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.LastActivity != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.LastActivity.Size()))
		n5, err := m.LastActivity.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Operator {
		data[i] = 0x40
		i++
		if m.Operator {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.AwayMsg) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.AwayMsg)))
		i += copy(data[i:], m.AwayMsg)
	}
	if m.ThrottlingExponent != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.ThrottlingExponent))
	}
	if len(m.InvitedTo) > 0 {
		for _, s := range m.InvitedTo {
			data[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Modes) > 0 {
		for _, s := range m.Modes {
			data[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Svid) > 0 {
		data[i] = 0x6a
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.Svid)))
		i += copy(data[i:], m.Svid)
	}
	if len(m.Pass) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.Pass)))
		i += copy(data[i:], m.Pass)
	}
	if m.Server {
		data[i] = 0x78
		i++
		if m.Server {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.LastClientMessageId != 0 {
		data[i] = 0x88
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.LastClientMessageId))
	}
	if m.IrcPrefix != nil {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.IrcPrefix.Size()))
		n6, err := m.IrcPrefix.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.LastNonPing != nil {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.LastNonPing.Size()))
		n7, err := m.LastNonPing.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.LastSolvedCaptcha != nil {
		data[i] = 0xa2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.LastSolvedCaptcha.Size()))
		n8, err := m.LastSolvedCaptcha.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.LoggedIn != 0 {
		data[i] = 0xa8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.LoggedIn))
	}
	if m.Created != 0 {
		data[i] = 0xb0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.Created))
	}
	if len(m.RemoteAddr) > 0 {
		data[i] = 0xba
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.RemoteAddr)))
		i += copy(data[i:], m.RemoteAddr)
	}
	return i, nil
}

func (m *Snapshot_Channel) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Snapshot_Channel) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.TopicNick) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.TopicNick)))
		i += copy(data[i:], m.TopicNick)
	}
	if m.TopicTime != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.TopicTime.Size()))
		n9, err := m.TopicTime.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Topic) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.Topic)))
		i += copy(data[i:], m.Topic)
	}
	if len(m.Nicks) > 0 {
		for k, _ := range m.Nicks {
			data[i] = 0x2a
			i++
			v := m.Nicks[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovSnapshot(uint64(len(k))) + 1 + msgSize + sovSnapshot(uint64(msgSize))
			i = encodeVarintSnapshot(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintSnapshot(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintSnapshot(data, i, uint64(v.Size()))
			n10, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n10
		}
	}
	if len(m.Modes) > 0 {
		for _, s := range m.Modes {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Bans) > 0 {
		for _, msg := range m.Bans {
			data[i] = 0x3a
			i++
			i = encodeVarintSnapshot(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Snapshot_Channel_Modes) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Snapshot_Channel_Modes) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mode) > 0 {
		for _, s := range m.Mode {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *Snapshot_Channel_BanPattern) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Snapshot_Channel_BanPattern) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pattern) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.Pattern)))
		i += copy(data[i:], m.Pattern)
	}
	if len(m.Regexp) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.Regexp)))
		i += copy(data[i:], m.Regexp)
	}
	return i, nil
}

func (m *Snapshot_SVSHold) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Snapshot_SVSHold) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Added != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.Added.Size()))
		n11, err := m.Added.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Duration) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.Duration)))
		i += copy(data[i:], m.Duration)
	}
	if len(m.Reason) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	return i, nil
}

func (m *Snapshot_Config) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Snapshot_Config) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Revision != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.Revision))
	}
	if m.Irc != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.Irc.Size()))
		n12, err := m.Irc.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.SessionExpiration) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.SessionExpiration)))
		i += copy(data[i:], m.SessionExpiration)
	}
	if len(m.PostMessageCooloff) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.PostMessageCooloff)))
		i += copy(data[i:], m.PostMessageCooloff)
	}
	if len(m.TrustedBridges) > 0 {
		for k, _ := range m.TrustedBridges {
			data[i] = 0x2a
			i++
			v := m.TrustedBridges[k]
			mapSize := 1 + len(k) + sovSnapshot(uint64(len(k))) + 1 + len(v) + sovSnapshot(uint64(len(v)))
			i = encodeVarintSnapshot(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintSnapshot(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintSnapshot(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if len(m.CaptchaUrl) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.CaptchaUrl)))
		i += copy(data[i:], m.CaptchaUrl)
	}
	if len(m.CaptchaHmacSecret) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.CaptchaHmacSecret)))
		i += copy(data[i:], m.CaptchaHmacSecret)
	}
	if m.CaptchaRequiredForLogin {
		data[i] = 0x40
		i++
		if m.CaptchaRequiredForLogin {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.MaxSessions != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.MaxSessions))
	}
	if m.MaxChannels != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintSnapshot(data, i, uint64(m.MaxChannels))
	}
	if len(m.Banned) > 0 {
		for k, _ := range m.Banned {
			data[i] = 0x5a
			i++
			v := m.Banned[k]
			mapSize := 1 + len(k) + sovSnapshot(uint64(len(k))) + 1 + len(v) + sovSnapshot(uint64(len(v)))
			i = encodeVarintSnapshot(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintSnapshot(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintSnapshot(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *Snapshot_Config_IRC) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Snapshot_Config_IRC) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Operators) > 0 {
		for _, msg := range m.Operators {
			data[i] = 0xa
			i++
			i = encodeVarintSnapshot(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Services) > 0 {
		for _, msg := range m.Services {
			data[i] = 0x12
			i++
			i = encodeVarintSnapshot(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Snapshot_Config_IRC_Operator) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Snapshot_Config_IRC_Operator) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Password) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.Password)))
		i += copy(data[i:], m.Password)
	}
	return i, nil
}

func (m *Snapshot_Config_IRC_Service) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Snapshot_Config_IRC_Service) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Password) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSnapshot(data, i, uint64(len(m.Password)))
		i += copy(data[i:], m.Password)
	}
	return i, nil
}

func encodeFixed64Snapshot(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Snapshot(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSnapshot(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Timestamp) Size() (n int) {
	var l int
	_ = l
	if m.UnixNano != 0 {
		n += 1 + sovSnapshot(uint64(m.UnixNano))
	}
	if m.IsZero {
		n += 2
	}
	return n
}

func (m *Snapshot) Size() (n int) {
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	if len(m.Channels) > 0 {
		for _, e := range m.Channels {
			l = e.Size()
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	if len(m.Svsholds) > 0 {
		for k, v := range m.Svsholds {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovSnapshot(uint64(len(k))) + 1 + l + sovSnapshot(uint64(l))
			n += mapEntrySize + 1 + sovSnapshot(uint64(mapEntrySize))
		}
	}
	if m.LastProcessed != nil {
		l = m.LastProcessed.Size()
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.LastIncludedIndex != 0 {
		n += 1 + sovSnapshot(uint64(m.LastIncludedIndex))
	}
	return n
}

func (m *Snapshot_IRCPrefix) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	return n
}

func (m *Snapshot_Session) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Auth)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Nick)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Realname)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if len(m.Channels) > 0 {
		for _, s := range m.Channels {
			l = len(s)
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	if m.LastActivity != nil {
		l = m.LastActivity.Size()
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.Operator {
		n += 2
	}
	l = len(m.AwayMsg)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.ThrottlingExponent != 0 {
		n += 1 + sovSnapshot(uint64(m.ThrottlingExponent))
	}
	if len(m.InvitedTo) > 0 {
		for _, s := range m.InvitedTo {
			l = len(s)
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	if len(m.Modes) > 0 {
		for _, s := range m.Modes {
			l = len(s)
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	l = len(m.Svid)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Pass)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.Server {
		n += 2
	}
	if m.LastClientMessageId != 0 {
		n += 2 + sovSnapshot(uint64(m.LastClientMessageId))
	}
	if m.IrcPrefix != nil {
		l = m.IrcPrefix.Size()
		n += 2 + l + sovSnapshot(uint64(l))
	}
	if m.LastNonPing != nil {
		l = m.LastNonPing.Size()
		n += 2 + l + sovSnapshot(uint64(l))
	}
	if m.LastSolvedCaptcha != nil {
		l = m.LastSolvedCaptcha.Size()
		n += 2 + l + sovSnapshot(uint64(l))
	}
	if m.LoggedIn != 0 {
		n += 2 + sovSnapshot(uint64(m.LoggedIn))
	}
	if m.Created != 0 {
		n += 2 + sovSnapshot(uint64(m.Created))
	}
	l = len(m.RemoteAddr)
	if l > 0 {
		n += 2 + l + sovSnapshot(uint64(l))
	}
	return n
}

func (m *Snapshot_Channel) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.TopicNick)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.TopicTime != nil {
		l = m.TopicTime.Size()
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if len(m.Nicks) > 0 {
		for k, v := range m.Nicks {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovSnapshot(uint64(len(k))) + 1 + l + sovSnapshot(uint64(l))
			n += mapEntrySize + 1 + sovSnapshot(uint64(mapEntrySize))
		}
	}
	if len(m.Modes) > 0 {
		for _, s := range m.Modes {
			l = len(s)
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	if len(m.Bans) > 0 {
		for _, e := range m.Bans {
			l = e.Size()
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	return n
}

func (m *Snapshot_Channel_Modes) Size() (n int) {
	var l int
	_ = l
	if len(m.Mode) > 0 {
		for _, s := range m.Mode {
			l = len(s)
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	return n
}

func (m *Snapshot_Channel_BanPattern) Size() (n int) {
	var l int
	_ = l
	l = len(m.Pattern)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Regexp)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	return n
}

func (m *Snapshot_SVSHold) Size() (n int) {
	var l int
	_ = l
	if m.Added != nil {
		l = m.Added.Size()
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Duration)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	return n
}

func (m *Snapshot_Config) Size() (n int) {
	var l int
	_ = l
	if m.Revision != 0 {
		n += 1 + sovSnapshot(uint64(m.Revision))
	}
	if m.Irc != nil {
		l = m.Irc.Size()
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.SessionExpiration)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.PostMessageCooloff)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if len(m.TrustedBridges) > 0 {
		for k, v := range m.TrustedBridges {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSnapshot(uint64(len(k))) + 1 + len(v) + sovSnapshot(uint64(len(v)))
			n += mapEntrySize + 1 + sovSnapshot(uint64(mapEntrySize))
		}
	}
	l = len(m.CaptchaUrl)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.CaptchaHmacSecret)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	if m.CaptchaRequiredForLogin {
		n += 2
	}
	if m.MaxSessions != 0 {
		n += 1 + sovSnapshot(uint64(m.MaxSessions))
	}
	if m.MaxChannels != 0 {
		n += 1 + sovSnapshot(uint64(m.MaxChannels))
	}
	if len(m.Banned) > 0 {
		for k, v := range m.Banned {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSnapshot(uint64(len(k))) + 1 + len(v) + sovSnapshot(uint64(len(v)))
			n += mapEntrySize + 1 + sovSnapshot(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Snapshot_Config_IRC) Size() (n int) {
	var l int
	_ = l
	if len(m.Operators) > 0 {
		for _, e := range m.Operators {
			l = e.Size()
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovSnapshot(uint64(l))
		}
	}
	return n
}

func (m *Snapshot_Config_IRC_Operator) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	return n
}

func (m *Snapshot_Config_IRC_Service) Size() (n int) {
	var l int
	_ = l
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovSnapshot(uint64(l))
	}
	return n
}

func sovSnapshot(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSnapshot(x uint64) (n int) {
	return sovSnapshot(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Timestamp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnixNano", wireType)
			}
			m.UnixNano = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UnixNano |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsZero", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsZero = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Snapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Snapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &Snapshot_Session{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channels = append(m.Channels, &Snapshot_Channel{})
			if err := m.Channels[len(m.Channels)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svsholds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthSnapshot
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &Snapshot_SVSHold{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Svsholds == nil {
				m.Svsholds = make(map[string]*Snapshot_SVSHold)
			}
			m.Svsholds[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastProcessed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastProcessed == nil {
				m.LastProcessed = &RobustId{}
			}
			if err := m.LastProcessed.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &Snapshot_Config{}
			}
			if err := m.Config.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastIncludedIndex", wireType)
			}
			m.LastIncludedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastIncludedIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_IRCPrefix) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IRCPrefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IRCPrefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_Session) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &RobustId{}
			}
			if err := m.Id.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Auth = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nick", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nick = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Realname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Realname = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channels = append(m.Channels, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastActivity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastActivity == nil {
				m.LastActivity = &Timestamp{}
			}
			if err := m.LastActivity.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Operator = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwayMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwayMsg = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThrottlingExponent", wireType)
			}
			m.ThrottlingExponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ThrottlingExponent |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvitedTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvitedTo = append(m.InvitedTo, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Modes = append(m.Modes, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Svid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pass = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Server = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastClientMessageId", wireType)
			}
			m.LastClientMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastClientMessageId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IrcPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IrcPrefix == nil {
				m.IrcPrefix = &Snapshot_IRCPrefix{}
			}
			if err := m.IrcPrefix.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastNonPing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastNonPing == nil {
				m.LastNonPing = &Timestamp{}
			}
			if err := m.LastNonPing.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSolvedCaptcha", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastSolvedCaptcha == nil {
				m.LastSolvedCaptcha = &Timestamp{}
			}
			if err := m.LastSolvedCaptcha.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoggedIn", wireType)
			}
			m.LoggedIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LoggedIn |= (Bool(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Created |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteAddr = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_Channel) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Channel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Channel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicNick", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicNick = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopicTime == nil {
				m.TopicTime = &Timestamp{}
			}
			if err := m.TopicTime.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nicks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthSnapshot
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &Snapshot_Channel_Modes{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Nicks == nil {
				m.Nicks = make(map[string]*Snapshot_Channel_Modes)
			}
			m.Nicks[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Modes = append(m.Modes, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bans = append(m.Bans, &Snapshot_Channel_BanPattern{})
			if err := m.Bans[len(m.Bans)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_Channel_Modes) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Modes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Modes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = append(m.Mode, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_Channel_BanPattern) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BanPattern: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BanPattern: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regexp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regexp = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_SVSHold) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SVSHold: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SVSHold: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Added", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Added == nil {
				m.Added = &Timestamp{}
			}
			if err := m.Added.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Duration = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_Config) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Revision |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Irc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Irc == nil {
				m.Irc = &Snapshot_Config_IRC{}
			}
			if err := m.Irc.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionExpiration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionExpiration = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostMessageCooloff", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostMessageCooloff = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedBridges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthSnapshot
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthSnapshot
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.TrustedBridges == nil {
				m.TrustedBridges = make(map[string]string)
			}
			m.TrustedBridges[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptchaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaptchaUrl = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptchaHmacSecret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaptchaHmacSecret = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptchaRequiredForLogin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CaptchaRequiredForLogin = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSessions", wireType)
			}
			m.MaxSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MaxSessions |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxChannels", wireType)
			}
			m.MaxChannels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MaxChannels |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Banned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthSnapshot
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthSnapshot
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.Banned == nil {
				m.Banned = make(map[string]string)
			}
			m.Banned[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_Config_IRC) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IRC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IRC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operators = append(m.Operators, &Snapshot_Config_IRC_Operator{})
			if err := m.Operators[len(m.Operators)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &Snapshot_Config_IRC_Service{})
			if err := m.Services[len(m.Services)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_Config_IRC_Operator) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Operator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Operator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot_Config_IRC_Service) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSnapshot
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSnapshot(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSnapshot
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSnapshot(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSnapshot
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSnapshot
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSnapshot
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSnapshot
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSnapshot(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSnapshot = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSnapshot   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorSnapshot = []byte{
	// 1324 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xcd, 0x6e, 0x14, 0xc7,
	0x16, 0xa6, 0x3d, 0xbf, 0x7d, 0x06, 0xcc, 0xb8, 0x6c, 0xec, 0xa2, 0x11, 0xc6, 0xd7, 0x57, 0x17,
	0x59, 0xe8, 0x62, 0xae, 0xf0, 0x0d, 0x02, 0x22, 0xa1, 0xd8, 0x23, 0x13, 0x26, 0x02, 0xc7, 0xea,
	0x31, 0x89, 0x94, 0x4d, 0xab, 0xdc, 0x5d, 0x9e, 0x29, 0xd1, 0x53, 0xd5, 0xa9, 0xaa, 0x19, 0xc6,
	0x59, 0x67, 0x99, 0x07, 0xc8, 0x1b, 0xe4, 0x39, 0xb2, 0xcb, 0x32, 0x8f, 0x10, 0x91, 0x65, 0x5e,
	0x22, 0xaa, 0x9f, 0x6e, 0xdb, 0x78, 0x8c, 0x94, 0x55, 0xd7, 0x39, 0xdf, 0x57, 0xa7, 0xaa, 0xcf,
	0x6f, 0xc1, 0xa2, 0xe2, 0xa4, 0x50, 0x23, 0xa1, 0xb7, 0x0b, 0x29, 0xb4, 0x40, 0x0d, 0xfb, 0x89,
	0x3a, 0xfa, 0xb4, 0xa0, 0xca, 0xe9, 0x36, 0x77, 0x21, 0x3c, 0x62, 0x63, 0xaa, 0x34, 0x19, 0x17,
	0xe8, 0x0e, 0x84, 0x13, 0xce, 0x66, 0x09, 0x27, 0x5c, 0xe0, 0x60, 0x23, 0xd8, 0xaa, 0xc5, 0x6d,
	0xa3, 0x38, 0x20, 0x5c, 0xa0, 0x35, 0x68, 0x31, 0x95, 0xfc, 0x40, 0xa5, 0xc0, 0x0b, 0x1b, 0xc1,
	0x56, 0x3b, 0x6e, 0x32, 0xf5, 0x1d, 0x95, 0x62, 0xf3, 0x97, 0x5b, 0xd0, 0x1e, 0xf8, 0x93, 0xd0,
	0x0e, 0xb4, 0x15, 0x55, 0x8a, 0x09, 0xae, 0x70, 0xb0, 0x51, 0xdb, 0xea, 0x3c, 0x5e, 0x73, 0x27,
	0x6d, 0x97, 0x94, 0xed, 0x81, 0xc3, 0xe3, 0x8a, 0x68, 0x36, 0xa5, 0x23, 0xc2, 0x39, 0xcd, 0x15,
	0x5e, 0x98, 0xbf, 0xa9, 0xe7, 0xf0, 0xb8, 0x22, 0xa2, 0x67, 0xd0, 0x56, 0x53, 0x35, 0x12, 0x79,
	0xa6, 0x70, 0xcd, 0x6e, 0xba, 0x7b, 0xe9, 0x24, 0x8f, 0xef, 0x73, 0x2d, 0x4f, 0xe3, 0x8a, 0x8e,
	0x9e, 0xc0, 0x62, 0x4e, 0x94, 0x4e, 0x0a, 0x29, 0x52, 0xaa, 0x14, 0xcd, 0x70, 0x7d, 0x23, 0xd8,
	0xea, 0x3c, 0xbe, 0xe9, 0x0d, 0xc4, 0xe2, 0x78, 0xa2, 0x74, 0x3f, 0x8b, 0x6f, 0x18, 0xda, 0x61,
	0xc9, 0x42, 0xdb, 0xd0, 0x4c, 0x05, 0x3f, 0x61, 0x43, 0xdc, 0xb0, 0xfc, 0xd5, 0x4b, 0xb7, 0xb4,
	0x68, 0xec, 0x59, 0x68, 0x1b, 0x96, 0xed, 0x39, 0x8c, 0xa7, 0xf9, 0x24, 0xa3, 0x59, 0xc2, 0x78,
	0x46, 0x67, 0xb8, 0xb9, 0x11, 0x6c, 0xd5, 0xe3, 0x25, 0x03, 0xf5, 0x3d, 0xd2, 0x37, 0x40, 0xf4,
	0x25, 0x84, 0xfd, 0xb8, 0x77, 0x28, 0xe9, 0x09, 0x9b, 0x21, 0x04, 0x75, 0x4e, 0xc6, 0xd4, 0xc6,
	0x21, 0x8c, 0xed, 0xda, 0xe8, 0x26, 0x8a, 0x4a, 0x1b, 0x80, 0x30, 0xb6, 0x6b, 0xa3, 0x1b, 0x09,
	0xa5, 0x71, 0xcd, 0xe9, 0xcc, 0x3a, 0xfa, 0xa9, 0x09, 0x2d, 0xef, 0x66, 0x74, 0x0f, 0x16, 0x58,
	0x66, 0xad, 0xcc, 0xf9, 0xc1, 0x05, 0x96, 0x19, 0x03, 0x64, 0xa2, 0x47, 0xa5, 0x51, 0xb3, 0xb6,
	0x87, 0xb3, 0xf4, 0x5d, 0x69, 0xd4, 0xac, 0x51, 0x04, 0x6d, 0x73, 0xa0, 0xbd, 0x54, 0xdd, 0xea,
	0x2b, 0xd9, 0x60, 0x92, 0x92, 0xdc, 0x62, 0x0d, 0x87, 0x95, 0xb2, 0xc1, 0xaa, 0xe8, 0x36, 0x37,
	0x6a, 0x06, 0xab, 0x82, 0xf8, 0x19, 0x58, 0x17, 0x27, 0x24, 0xd5, 0x6c, 0xca, 0xf4, 0x29, 0x6e,
	0xd9, 0x7b, 0x76, 0xfd, 0x3d, 0xab, 0xd4, 0x8c, 0xaf, 0x1b, 0xda, 0xae, 0x67, 0x19, 0x93, 0xa2,
	0xa0, 0x92, 0x68, 0x21, 0x71, 0xdb, 0x26, 0x63, 0x25, 0xa3, 0xdb, 0xd0, 0x26, 0xef, 0xc9, 0x69,
	0x32, 0x56, 0x43, 0x1c, 0xda, 0xab, 0xb4, 0x8c, 0xfc, 0x46, 0x0d, 0xd1, 0x23, 0x58, 0xd6, 0x23,
	0x29, 0xb4, 0xce, 0x19, 0x1f, 0x26, 0x74, 0x56, 0x08, 0x4e, 0xb9, 0xc6, 0x60, 0x33, 0x1d, 0x9d,
	0x41, 0xfb, 0x1e, 0x41, 0x77, 0x01, 0x18, 0x9f, 0x32, 0x4d, 0xb3, 0x44, 0x0b, 0xdc, 0xb1, 0x97,
	0x0f, 0xbd, 0xe6, 0x48, 0xa0, 0x15, 0x68, 0x8c, 0x45, 0x46, 0x15, 0xbe, 0x6e, 0x11, 0x27, 0x18,
	0xdf, 0xa9, 0x29, 0xcb, 0xf0, 0x0d, 0xe7, 0x3b, 0xb3, 0x36, 0xba, 0x82, 0x28, 0x85, 0x17, 0x9d,
	0xce, 0xac, 0xd1, 0x2a, 0x34, 0x15, 0x95, 0x53, 0x2a, 0xf1, 0x4d, 0x57, 0x4f, 0x4e, 0x42, 0x3b,
	0xb0, 0x6a, 0x7d, 0x92, 0xe6, 0x8c, 0x72, 0x9d, 0x8c, 0xa9, 0x52, 0x64, 0x48, 0x13, 0x96, 0xe1,
	0x25, 0x9b, 0x38, 0x36, 0xa7, 0x7a, 0x16, 0x7c, 0xe3, 0xb0, 0x7e, 0x86, 0x9e, 0x02, 0x30, 0x99,
	0x26, 0x85, 0xcd, 0x1d, 0x8c, 0xac, 0x17, 0x6f, 0x7f, 0x9c, 0x9e, 0x55, 0x72, 0xc5, 0x21, 0x93,
	0xa9, 0xcf, 0xb3, 0xff, 0xfb, 0x10, 0x70, 0xc1, 0x93, 0x82, 0xf1, 0x21, 0x5e, 0xbe, 0x22, 0x04,
	0x1d, 0x43, 0x3b, 0x10, 0xfc, 0x90, 0xf1, 0x21, 0xfa, 0xc2, 0xa7, 0xb6, 0x12, 0xf9, 0x94, 0x66,
	0x49, 0x4a, 0x0a, 0x9d, 0x8e, 0x08, 0x5e, 0xb9, 0x62, 0xaf, 0x4d, 0xf6, 0x81, 0xe5, 0xf6, 0x1c,
	0x15, 0x6d, 0x41, 0x98, 0x8b, 0xe1, 0xd0, 0x56, 0x05, 0xbe, 0xb5, 0x11, 0x6c, 0x2d, 0x3e, 0xee,
	0xf8, 0x7d, 0x7b, 0x42, 0xe4, 0x71, 0xdb, 0xa1, 0x7d, 0x8e, 0x30, 0xb4, 0x52, 0x49, 0x89, 0xa6,
	0x19, 0x5e, 0xb5, 0xa1, 0x2a, 0x45, 0x74, 0x0f, 0x3a, 0x92, 0x8e, 0x85, 0xa6, 0x09, 0xc9, 0x32,
	0x89, 0xd7, 0xac, 0x77, 0xc1, 0xa9, 0x76, 0xb3, 0x4c, 0x7e, 0x55, 0x6f, 0x77, 0xbb, 0x4b, 0xd1,
	0xaf, 0x35, 0x68, 0xf9, 0x06, 0x32, 0xb7, 0xac, 0xee, 0x02, 0x68, 0x51, 0xb0, 0x34, 0xb1, 0x39,
	0xef, 0xea, 0x20, 0xb4, 0x9a, 0x03, 0x93, 0xf8, 0x8f, 0x4a, 0x58, 0xb3, 0x31, 0xb5, 0x25, 0x31,
	0xef, 0x17, 0xdd, 0x06, 0x23, 0x9b, 0xbc, 0xb0, 0x82, 0x2f, 0x13, 0x27, 0xa0, 0xa7, 0xd0, 0x30,
	0xf6, 0x15, 0x6e, 0xd8, 0x6e, 0xb5, 0x79, 0x45, 0x8b, 0xdb, 0x36, 0x67, 0xfa, 0x96, 0xe5, 0x36,
	0x9c, 0xe5, 0x59, 0xf3, 0x7c, 0x9e, 0x3d, 0x81, 0xfa, 0x31, 0xe1, 0x0a, 0xb7, 0x3e, 0x6d, 0x6e,
	0x8f, 0xf0, 0x43, 0xa2, 0x35, 0x95, 0x3c, 0xb6, 0xfc, 0xe8, 0x0e, 0x34, 0xde, 0x94, 0x89, 0x6a,
	0x2c, 0xd9, 0x3e, 0x1d, 0xc6, 0x76, 0x1d, 0x7d, 0x0b, 0x70, 0x76, 0x3e, 0xea, 0x42, 0xed, 0x1d,
	0x3d, 0xf5, 0xbe, 0x32, 0x4b, 0xb4, 0x03, 0x8d, 0x29, 0xc9, 0x27, 0xd4, 0x7a, 0x69, 0x4e, 0xcb,
	0x2d, 0x4f, 0xb5, 0x27, 0xc4, 0x8e, 0xfb, 0x7c, 0xe1, 0x69, 0x10, 0xbd, 0x00, 0x38, 0xbb, 0x89,
	0x09, 0x69, 0xe1, 0x96, 0xde, 0x78, 0x29, 0x9a, 0xaa, 0x90, 0x74, 0x48, 0x67, 0x85, 0x8f, 0x83,
	0x97, 0x22, 0x0a, 0xad, 0xc1, 0x37, 0x83, 0x57, 0x22, 0xcf, 0xd0, 0x7d, 0x68, 0x90, 0x2c, 0xa3,
	0x65, 0x53, 0xbb, 0x1c, 0x0a, 0x07, 0x9b, 0x2e, 0x91, 0x4d, 0x24, 0xd1, 0x4c, 0x70, 0x6f, 0xac,
	0x92, 0xdd, 0x31, 0x44, 0x09, 0xee, 0x5b, 0x9c, 0x97, 0xa2, 0x23, 0xb8, 0x71, 0x61, 0x6a, 0xcc,
	0x71, 0xc1, 0xc3, 0x8b, 0x2e, 0xb8, 0x3c, 0xdf, 0xdc, 0x35, 0xcf, 0xff, 0xfc, 0x8f, 0x2d, 0x68,
	0xba, 0xd9, 0xe0, 0x3a, 0xe5, 0x94, 0x99, 0xd6, 0x6c, 0x8d, 0xd6, 0xe3, 0x4a, 0x46, 0xff, 0x85,
	0x1a, 0x93, 0xa9, 0xb7, 0x1b, 0xcd, 0x1f, 0x2e, 0xa6, 0x88, 0x63, 0x43, 0x43, 0x0f, 0x01, 0xf9,
	0x09, 0x6a, 0x5a, 0x19, 0xf3, 0x3f, 0xea, 0x7e, 0x67, 0xc9, 0x23, 0xfb, 0x15, 0x80, 0xfe, 0x07,
	0x2b, 0x85, 0x50, 0x67, 0xfd, 0x24, 0x15, 0x22, 0x17, 0x27, 0x27, 0x3e, 0x47, 0x91, 0xc1, 0x7c,
	0x3b, 0xe9, 0x39, 0x04, 0x0d, 0xe0, 0xa6, 0x96, 0x13, 0x65, 0xba, 0xdf, 0xb1, 0x64, 0xd9, 0x90,
	0x96, 0xa9, 0xfb, 0xe0, 0x8a, 0xab, 0x1d, 0x39, 0xf6, 0x9e, 0x23, 0xbb, 0x14, 0x5e, 0xd4, 0x17,
	0x94, 0xa6, 0x64, 0x7d, 0xb3, 0x48, 0x26, 0x32, 0xb7, 0xb3, 0x30, 0x8c, 0xc1, 0xab, 0xde, 0xca,
	0xdc, 0x0c, 0xcd, 0x92, 0x30, 0x1a, 0x93, 0x34, 0x51, 0x34, 0x95, 0x54, 0xdb, 0xc1, 0x10, 0xc6,
	0x4b, 0x1e, 0x7a, 0x35, 0x26, 0xe9, 0xc0, 0x02, 0xe8, 0x73, 0x88, 0x4a, 0xbe, 0xa4, 0xdf, 0x4f,
	0x98, 0xa4, 0x59, 0x72, 0x22, 0x64, 0x92, 0x8b, 0x21, 0xe3, 0x7e, 0x3a, 0xac, 0x79, 0x46, 0xec,
	0x09, 0x2f, 0x85, 0x7c, 0x6d, 0x60, 0xf4, 0x2f, 0xb8, 0x3e, 0x26, 0xb3, 0xa4, 0x7a, 0xb2, 0x84,
	0x36, 0x22, 0x9d, 0x31, 0x99, 0x0d, 0xca, 0xc7, 0x89, 0xa7, 0x54, 0x23, 0x0c, 0x2a, 0x4a, 0xaf,
	0x9c, 0x62, 0xcf, 0xa1, 0x79, 0x6c, 0x96, 0x99, 0x1d, 0x11, 0xf3, 0x6a, 0xd1, 0xf9, 0x67, 0xcf,
	0x92, 0x9c, 0x5f, 0xfc, 0x8e, 0xe8, 0xaf, 0x00, 0x6a, 0xfd, 0xb8, 0x87, 0x76, 0x21, 0x2c, 0x47,
	0x58, 0xf9, 0x72, 0xfa, 0xf7, 0xd5, 0x19, 0xb0, 0xfd, 0xb5, 0xe7, 0xc6, 0x67, 0xbb, 0xd0, 0x0b,
	0xf3, 0xf6, 0x92, 0x53, 0x96, 0xd2, 0xf2, 0x19, 0xb5, 0xf9, 0x09, 0x0b, 0x03, 0x47, 0x8d, 0xab,
	0x3d, 0xd1, 0x73, 0x68, 0x97, 0x66, 0xe7, 0xb6, 0xc9, 0x08, 0xda, 0x66, 0x70, 0xbd, 0x17, 0x32,
	0x2b, 0xeb, 0xa9, 0x94, 0xa3, 0xff, 0x98, 0x07, 0x87, 0xb5, 0x73, 0x81, 0x16, 0x7c, 0x44, 0xdb,
	0x85, 0xe5, 0x39, 0x49, 0x32, 0xa7, 0xc8, 0x56, 0xce, 0x17, 0x59, 0x78, 0xbe, 0x96, 0x9e, 0x41,
	0xe7, 0x9c, 0x1f, 0xff, 0xc9, 0xd6, 0x07, 0xf7, 0xa1, 0x6e, 0x46, 0x0b, 0x0a, 0xa1, 0xf1, 0xf6,
	0x60, 0xb0, 0x7f, 0xd4, 0xbd, 0x86, 0xda, 0x50, 0x3f, 0x8a, 0xdf, 0xee, 0x77, 0x03, 0xa3, 0x7c,
	0xb9, 0xfb, 0x7a, 0xb0, 0xdf, 0x5d, 0xd8, 0xeb, 0xfe, 0xf6, 0x61, 0x3d, 0xf8, 0xfd, 0xc3, 0x7a,
	0xf0, 0xc7, 0x87, 0xf5, 0xe0, 0xe7, 0x3f, 0xd7, 0xaf, 0x1d, 0x37, 0xad, 0x1f, 0x77, 0xfe, 0x0e,
	0x00, 0x00, 0xff, 0xff, 0x8f, 0xf2, 0xa2, 0x45, 0x53, 0x0b, 0x00, 0x00,
}
